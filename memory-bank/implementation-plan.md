# 凡人修仙传·掌上仙途 - 基础版实施计划 (MVP Implementation Plan)

本计划旨在指导 AI 开发者构建《凡人修仙传·掌上仙途》的最小可行性产品 (MVP)。
**目标**：完成核心的“创建角色”、“挂机修炼”、“境界突破”闭环。

---

## 第一阶段：环境搭建与基础设施 (Phase 1: Infrastructure)

### 步骤 1.1: 初始化 Nuxt 3 项目
*   **指令**: 使用 `npx nuxi init` 初始化项目。
*   **配置**: 确保 TypeScript 严格模式已启用。
*   **验证**: 运行 `npm run dev`，确保浏览器能访问默认欢迎页面，且控制台无报错。

### 步骤 1.2: 安装核心依赖
*   **指令**: 安装以下包：
    *   UI 组件库: `vant` (以及 `@vant/nuxt` 用于自动集成)。
    *   状态管理: `@pinia/nuxt` 和 `pinia`。
    *   工具库: `@vueuse/nuxt` 和 `@vueuse/core`。
    *   数据库/ORM: `prisma` (开发依赖) 和 `@prisma/client`。
*   **验证**: 检查 `package.json` 包含上述依赖。运行 `npm run dev` 确保插件注入正常（无启动错误）。

### 步骤 1.3: 配置 Vant UI (移动端适配)
*   **指令**: 在 `nuxt.config.ts` 中注册 Vant 模块。配置 `viewport` meta 标签以禁用用户缩放（移动端标准）。
*   **验证**: 在 `app.vue` 中添加一个 `<van-button type="primary">Test</van-button>`。启动应用，检查按钮样式是否为 Vant 样式，且在手机模式下显示正常。

### 步骤 1.4: 初始化 Prisma 与 SQLite
*   **指令**: 初始化 Prisma (`npx prisma init`)。配置 `datasource` 为 `sqlite`。
*   **验证**: 检查项目根目录是否生成 `prisma/schema.prisma` 和 `.env` 文件。

---

## 第二阶段：数据模型与角色系统 (Phase 2: Data Modeling & User System)

### 步骤 2.1: 定义 User 模型
*   **指令**: 在 `prisma/schema.prisma` 中定义 `User` 模型。
*   包含字段：
*   *   `id` (Int, autoincrement)
*   *   `username` (String, unique) —— 账号名
*   *   `passwordHash` (String) —— 使用安全哈希算法（如 Argon2 或 Bcrypt）存储密码
*   *   `email` (String?, unique) —— 预留邮箱绑定登录（MVP 阶段可为空）
*   *   `realm` (Enum) —— 当前境界，存储枚举 key（如 `QI_1`、`QI_2`）
*   *   `realmLabel` (String) —— 当前境界展示名称（如 "炼气一层"），便于直接渲染
*   *   `cultivation` (Int, 默认 0) —— 当前修为
*   *   `maxCultivation` (Int) —— 当前境界修为上限
*   *   `spiritRoot` (Enum) —— 英文枚举，表示灵根类型（存枚举 key）
*   *   `spiritRootLabel` (String) —— 灵根展示名称（如 "伪灵根"）
*   *   `lastCultivateAt` (DateTime?) —— 上次结算修炼时间，用于根据真实时间差计算修为增长
*   定义 `Realm` 与 `SpiritRoot` 枚举（英文枚举 + 前端映射中文）：
*   *   例如 `Realm` 中包含 `QI_1` ~ `QI_10` 分别对应 炼气一层 ~ 炼气十层。
*   *   例如 `SpiritRoot` 中包含 `FAKE`, `TRUE`, `HEAVEN`, `MUTANT` 分别对应 伪灵根/真灵根/天灵根/变异灵根，分布大致均匀。
*   执行 `npx prisma db push` 同步数据库。
*   **验证**: 运行 `npx prisma studio`，尝试手动添加一条 User 记录，保存成功即通过，确认 `realm` 与 `spiritRoot` 字段为枚举 key、`realmLabel` 与 `spiritRootLabel` 为中文展示文案。

### 步骤 2.2: 全局认证与错误返回约定
*   **认证令牌**:
*   *   使用 JWT（如 HS256），Payload 至少包含 `userId` 与过期时间。
*   *   登录成功后，在服务端设置 HttpOnly Cookie（如 `auth_token`）存储 JWT，作为身份的主存储。
*   *   前端调用受保护 API 时，通过读取 Cookie 中的 JWT，并在请求头附加 `Authorization: Bearer <token>`，以便后端统一从 Header 校验。
*   *   所有需要身份的后端接口优先从 Header 中读取 JWT，必要时可从 Cookie 兜底读取。
*   **密码安全**:
*   *   使用适合生产环境的密码哈希算法（如 Argon2id 或 Bcrypt），配置合理的成本参数，严禁使用明文或单次散列。
*   **统一错误返回结构**:
*   *   所有业务错误统一返回结构：`{ success: false, code: string, message: string }`。
*   *   `code` 为稳定的英文/下划线枚举（如 `AUTH_INVALID_CREDENTIALS`），供前端逻辑判断。
*   *   `message` 为给玩家看的中文提示文案（如 "账号或密码错误"）。
*   *   同时配合合适的 HTTP 状态码（如 400/401/403/409 等），便于调试与监控。

### 步骤 2.3: 后端 API - 注册
*   **指令**: 创建 `server/api/user/register.post.ts`。
*   *   接收 `username` 与 `password`。
*   *   使用安全哈希算法（如 Argon2 或 Bcrypt）计算 `passwordHash` 并存入数据库。
*   *   随机生成 `spiritRoot`（使用近似均匀分布从 `SpiritRoot` 枚举中选择），同步写入 `spiritRoot` 与 `spiritRootLabel`。
*   *   初始化 `realm` 为 `Realm.QI_1`，`realmLabel` 为 "炼气一层"。
*   *   初始化 `cultivation = 0`，`maxCultivation` 由 `gameConstants` 中的境界配置决定（炼气一层为 100）。
*   *   将 `lastCultivateAt` 设为当前时间。
*   *   返回新创建的用户对象（不返回登录 token）。
*   *   若用户名已存在等业务错误，使用统一错误结构返回（如 `code: "AUTH_USERNAME_TAKEN"`，`message: "该账号已被注册"`）。
*   **验证**: 使用 HTTP 客户端 (如 Postman 或 curl) 发送 POST 请求到 `/api/user/register`。检查返回的 JSON 是否包含 ID、灵根等字段，且数据库成功新增记录；重复注册同名账号时应返回统一结构的错误信息。

### 步骤 2.4: 后端 API - 登录
*   **指令**: 创建 `server/api/user/login.post.ts`。
*   *   接收 `username` 与 `password`。
*   *   根据 `username` 查询对应用户，验证密码哈希是否匹配。
*   *   校验通过后，生成 JWT（包含 `userId` 与过期时间），使用服务器密钥签名。
*   *   在服务端设置 HttpOnly Cookie（如 `auth_token`）存储 JWT，并在响应中附带基础玩家信息。
*   *   返回登录成功结果：包含 `success: true`、玩家基础信息等字段，前端无需手动存储明文密码或 token。
*   *   密码错误或账号不存在时，使用统一的错误结构返回（如 `code: "AUTH_INVALID_CREDENTIALS"`，`message: "账号或密码错误"`）。
*   **验证**: 使用 HTTP 客户端调用 `/api/user/login`，在密码正确/错误时分别验证返回结果是否符合预期；检查响应中是否正确设置了 HttpOnly Cookie，并确认后续受保护 API 能从 Cookie/Authorization Header 中解析并校验 JWT。

### 步骤 2.5: 前端 Store - 玩家状态管理
*   **指令**: 创建 `stores/player.ts` (Pinia store)。
*   State: `playerInfo` (User 类型 | null)，`token` (string | null)。
*   Actions:
*   *   `register(username, password)` —— 调用注册接口，仅在成功时更新本地玩家信息。
*   *   `login(username, password)` —— 调用登录接口，在成功时从响应中读取玩家信息并持久化；JWT 由服务端通过 HttpOnly Cookie 管理。
*   *   `fetchProfile()` —— 调用受保护接口（如 `/api/user/profile`）获取最新用户信息，自动依赖 Cookie 中的 JWT 完成身份校验。
*   **验证**: 在 Vue 组件中调用 `usePlayerStore()`，检查 Vue DevTools 中是否能看到 store 实例。

### 步骤 2.6: 前端界面 - 登录页
*   **指令**: 创建 `pages/login.vue`。
    *   页面文案偏向“登录/进入游戏”。
    *   使用 `van-field` 输入账号（用户名）与密码。
*   *   使用 `van-button` 提交，调用登录接口。
*   *   登录成功后，保存玩家信息，并跳转至首页（JWT 存在于 HttpOnly Cookie 中）。
    *   提供“前往注册”入口（可跳转到单独注册页，或在同页使用切换卡片）。
*   **验证**: 访问 `/login`，输入账号密码，点击登录。成功后应跳转首页，且网络面板看到 `/api/user/login` 调用成功，Pinia 中存有玩家信息，浏览器中存在 HttpOnly Cookie（如 `auth_token`）。

### 步骤 2.7: 前端界面 - 注册页
*   **指令**: 创建独立的注册 UI（单独页面或与登录页共用组件）。
    *   使用 `van-field` 输入账号与密码。
    *   使用 `van-button` 提交注册表单。
    *   注册成功后可自动跳转登录页或直接登录并跳转首页。
*   **验证**: 通过注册入口成功创建新账号，数据库新增用户记录。

---

## 第三阶段：核心玩法 - 修炼循环 (Phase 3: Core Loop - Cultivation)

### 步骤 3.1: 游戏数值配置
*   **指令**: 创建 `utils/gameConstants.ts` (确保前后端均可导入)。
*   定义境界列表，仅覆盖炼气一层 ~ 炼气十层，形成完整闭环。
*   定义每个境界的修为止限 (Max XP)：
*   *   炼气一层 `maxCultivation = 100`。
*   *   后续层数按倍数递增（例如 1.5 倍或 2 倍），保证层数越高所需修为显著增加。
*   定义基础修炼速度 (Base Cultivation Speed)，如每秒基础 +1 修为。具体数值与系数（灵根系数、境界系数）以当前版本为占位实现，后续可根据平衡性需求调整。
*   **验证**: 创建一个临时测试脚本，打印出"炼气一层"的修为上限，确保读取正确。

### 步骤 3.2: 后端 API - 修炼 (Tick)
*   **指令**: 创建 `server/api/game/cultivate.post.ts`。
*   *   从请求附带的 JWT 中解析 `userId`（优先从 `Authorization` Header 的 Bearer Token，必要时可从 HttpOnly Cookie 中读取）。
*   *   读取用户当前数据（包括 `spiritRoot`、`realm`、`cultivation`、`maxCultivation`、`lastCultivateAt`）。
*   根据真实时间差计算本次应增长的修为：
    *   计算当前时间与 `lastCultivateAt`（若为空则使用当前时间）之间的秒数。
    *   使用基础修炼速度 × 灵根系数 × 境界系数 × 时间差，得到应增加的修为值。
*   *   将本次增长累加到 `cultivation`，但不超过 `maxCultivation`，并更新 `lastCultivateAt` 为当前时间。
*   *   返回更新后的修为值与玩家状态。
*   *   对于 token 无效、用户不存在等情况，使用统一错误结构返回（如 `code: "AUTH_UNAUTHORIZED"` 或 `code: "USER_NOT_FOUND"`）。
*   **验证**: 手动调用 API。多次调用时检查数据库中该用户的 `cultivation` 值是否随时间合理增加，并验证长时间不调用后再调用时，是否按时间差一次性结算修为；在未登录或 token 无效时，应返回统一结构的错误信息。

### 步骤 3.3: 前端界面 - 主页 (修炼面板)
*   **指令**: 创建/更新 `pages/index.vue`。
    *   展示玩家信息：`username`, `realm`, `spirit_root`。
    *   展示修为进度条：使用 `van-progress`，计算 `cultivation / max_cultivation`。
    *   添加“打坐”按钮。
*   **验证**: 登录后进入主页，应看到注册时的信息。进度条应显示 0%。

### 步骤 3.4: 前端逻辑 - 自动/手动修炼
*   **指令**: 在主页实现修炼逻辑。
*   *   点击“打坐”按钮触发一次 API 调用，更新 Store 中的修为数据。
*   *   使用 `useIntervalFn` 实现前端自动轮询 (模拟挂机)，固定为每秒调用一次 `cultivate` API。
*   *   **验证**: 点击按钮，进度条应肉眼可见地增长。刷新页面，进度条应保持在增长后的位置 (数据持久化验证)；开启自动轮询后，每秒应看到修为平滑增长。

---

## 第四阶段：境界突破系统 (Phase 4: Breakthrough System)

### 步骤 4.1: 后端 API - 突破
*   **指令**: 创建 `server/api/game/breakthrough.post.ts`。
*   *   从 JWT 中解析当前用户。
*   *   检查当前 `realm` 是否已为配置中的最高境界（如 `Realm.QI_10`）。若是，返回统一错误结构（如 `code: "BREAKTHROUGH_MAX_REALM"`，`message: "已达当前版本最高境界"`）。
*   *   检查 `cultivation` 是否达到 `maxCultivation`。若未达到，返回统一错误结构（如 `code: "BREAKTHROUGH_CULTIVATION_NOT_ENOUGH"`，`message: "当前修为尚未圆满"`）。
*   *   在当前版本中，突破成功率设为 100%（后续可调整为固定概率）。如将来设置为 <100% 时，突破失败扣除中偏轻的修为（例如约 30% 当前境界上限）。
*   *   成功：`realm` 提升至下一阶，`realmLabel` 更新为对应中文名称，`cultivation` 重置或按规则扣除后重置，`maxCultivation` 根据新境界从 `gameConstants` 中更新。
*   *   返回突破结果 (Success/Fail) 及最新状态。
*   **验证**:
*   1. 修改数据库，将修为设为上限值。
*   2. 调用 API。
*   3. 检查数据库 `realm` 与 `realmLabel` 字段是否变更。

### 步骤 4.2: 前端界面 - 突破反馈
*   **指令**: 在主页添加“突破”按钮。
    *   仅当 `cultivation >= max_cultivation` 时按钮可用 (高亮)。
    *   点击调用突破 API。
    *   使用 `showToast` (Vant) 显示“突破成功！”或“突破失败...”。
*   **验证**:
    1. 挂机直到修为满。
    2. 确认“突破”按钮亮起。
    3. 点击突破，看到成功提示，且境界文字变更 (如从"炼气一层"变为"炼气二层")，进度条归零。

---

## 第五阶段：UI 框架完善 (Phase 5: UI Polish)

### 步骤 5.1: 底部导航栏
*   **指令**: 创建 `layouts/default.vue`。
    *   使用 `van-tabbar`。
    *   包含标签：修炼 (Home), 洞府 (Cave), 行囊 (Inventory)。
    *   配置路由跳转。
*   **验证**: 点击底部不同图标，URL 发生变化，且页面内容正确切换。

### 步骤 5.2: 路由守卫 (Auth Guard)
*   **指令**: 创建 Nuxt 中间件 `middleware/auth.global.ts`。
*   *   优先从 Cookie（如 `auth_token`）中检查是否存在有效 JWT。
*   *   若 Cookie 中不存在或解析失败，则视为未登录；如果当前不在登录页，强制重定向到 `/login`。
*   *   在客户端导航时，可结合 Pinia Store 中的 `playerInfo` 做额外兜底检查，避免使用过期的本地状态。
*   *   **验证**: 清除浏览器缓存与 Cookie，访问首页，应自动跳回登录页。登录后，应能正常访问首页；手动篡改或删除 Cookie 后再次访问，应被重新重定向到登录页。

---

## 第六阶段：洞府基础系统 (Phase 6: Cave - Basic System)

本阶段目标：实现一个最简版洞府（Cave），支持查看药园地块、种植基础灵草、收获成熟灵草，并与玩家身份和时间系统打通。复杂炼丹、炼器等后续扩展。

### 步骤 6.1: 设计洞府与地块数据模型
*   **指令**: 在 `prisma/schema.prisma` 中为洞府基础功能新增模型，用于表示玩家药园地块及其种植状态。为每个玩家设计固定数量的地块（例如 4 块），每块地记录所属玩家、地块索引、当前状态、种植的灵草类型、种植时间等信息。
*   *   状态字段使用 Prisma 枚举（例如 `EMPTY`/`GROWING`/`READY`）进行存储，避免使用魔法字符串。
*   *   不直接存储“预计成熟时间”，而是存储 `plantedAt`（种植时间）并在逻辑层结合配置中的“成熟时长（秒）”计算是否成熟。
*   **验证**: 保存 Schema 后运行 `npx prisma validate` 确认定义合法，无语法错误。

### 步骤 6.2: 同步洞府模型到数据库
*   **指令**: 运行 `npx prisma db push` 将新增的洞府与地块模型同步到 SQLite 数据库。
*   **验证**: 使用 `npx prisma studio` 打开数据库，确认新模型成功创建，并可以在界面中看到对应表结构。

### 步骤 6.3: 初始化玩家洞府地块
*   **指令**: 在用户注册流程中（或通过单独的初始化脚本）为每个新用户创建默认数量的药园地块记录，并将状态设置为“空置”。如果选择在注册接口中初始化，更新注册逻辑，使创建用户成功后自动为该用户插入对应地块数据。
*   **验证**: 注册一个新账号后，使用 Prisma Studio 或后端查询工具确认该用户名下的地块记录已按预期数量生成，状态均为“空置”。

### 步骤 6.4: 定义基础灵草类型常量
*   **指令**: 在前后端共享的配置位置（例如 `utils/gameConstants.ts`）为洞府准备最少数量的基础灵草类型（例如一到两种），为每种灵草定义唯一标识、显示名称与基础成熟时间（秒级）。保持配置简洁，仅用于验证种植与收获流程。
*   **验证**: 在一个临时测试脚本或控制台输出中读取这些灵草配置，确认每个灵草条目包含标识、名称和成熟时间，且无拼写错误。

### 步骤 6.5: 后端 API - 查询洞府状态
*   **指令**: 创建用于获取当前玩家洞府信息的接口，例如 `server/api/cave/status.get.ts`。接口通过签名 token 解析当前用户 ID，从数据库查询该用户的所有药园地块及其状态，并按照固定顺序返回给前端。
*   **验证**: 使用 HTTP 客户端调用该接口，在已登录状态下确认返回结果中包含所有地块信息，且字段与数据库内容一致；在未携带有效 token 的情况下调用时，应返回身份错误或未授权提示。

### 步骤 6.6: 后端 API - 种植灵草
*   **指令**: 创建用于种植灵草的接口，例如 `server/api/cave/plant.post.ts`。接口从 JWT 中获取当前用户，接收地块标识以及要种植的灵草标识，验证该地块属于当前用户且当前为空置，再根据灵草配置写入种植信息、更新状态并记录种植时间。
*   *   成熟判断统一基于 `plantedAt + 配置中的成熟时长（秒）` 进行计算，接口本身不直接存储预计成熟时间。
*   *   遇到非法请求（如地块不属于当前玩家、状态非空置）时使用统一错误结构返回。
*   **验证**: 使用 HTTP 客户端多次调用种植接口，测试以下情况：在空地上种植成功；尝试在已种植地块上重复种植时接口返回合理错误；尝试操作其他用户地块时被拒绝。

### 步骤 6.7: 后端 API - 收获灵草
*   **指令**: 创建用于收获灵草的接口，例如 `server/api/cave/harvest.post.ts`。接口根据 JWT 获取用户信息，接收地块标识，读取地块当前状态与种植时间，结合灵草配置中的成熟时长计算是否已达到可收获条件。若已成熟，将状态重置为空置并清空种植信息，同时返回本次收获的灵草信息以便后续加入行囊。
*   *   在未成熟、地块为空或不属于当前用户等情况下，使用统一错误结构返回（代码如 `CAVE_NOT_READY`、`CAVE_INVALID_SLOT` 等）。
*   **验证**: 手动调整数据库中的种植时间，使某块地被视为已成熟，然后调用收获接口确认：成功后地块状态回到空置，种植信息被清空，返回结果包含灵草信息；在未成熟时尝试收获应得到明确错误信息。

### 步骤 6.8: 前端页面 - 洞府基础布局
*   **指令**: 在 `pages/cave.vue` 中实现基础洞府界面结构，使用 Vant 组件展示若干固定地块，每块显示当前状态（空置/生长中/可收获）和灵草名称。页面加载时调用洞府状态接口，将返回的数据映射到界面元素上。
*   **验证**: 登录游戏后通过底部导航进入洞府页面，确认能够看到与数据库一致的地块数量与状态，并在网络面板中确认洞府状态接口被成功调用且返回正常。

### 步骤 6.9: 前端交互 - 种植灵草
*   **指令**: 在洞府页面为空置地块添加“种植”交互，例如点击空置地块弹出灵草选择面板，从基础灵草列表中选择一种后调用种植接口，并在成功后刷新洞府状态。确保种植操作只针对空置地块可用。
*   **验证**: 在洞府中选择空地完成一次种植操作，确认前端状态更新为“生长中”，刷新页面后状态保持；再次尝试对同一地块种植时应被前端和后端共同阻止。

### 步骤 6.10: 前端状态刷新与成熟显示
*   **指令**: 为洞府页面增加定时刷新机制与手动刷新按钮，用于周期性重新请求洞府状态接口，以反映灵草生长进度。
*   *   定时刷新推荐固定为每 5 秒请求一次状态接口，兼顾实时感与后端压力。
*   *   对于已达到成熟条件的地块，在前端显著标记为“可收获”，例如使用不同文案或颜色。
*   **验证**: 将某地块设置为接近成熟时间后观察洞府页面，确认在下一次刷新时该地块状态自动更新为“可收获”，并且收获接口能够成功处理；手动刷新按钮也能立即更新状态。

### 步骤 6.11: 前端交互 - 收获灵草
*   **指令**: 在洞府页面为标记为“可收获”的地块添加收获交互，点击后调用收获接口，成功后刷新洞府状态，并将收获结果暂时以提示形式展示（例如弹出提示显示获得了哪种灵草）。后续会在行囊系统中将这些收获记录为物品。
*   **验证**: 完成一次完整的“种植 → 等待成熟 → 收获”流程，确认前端显示、后端数据和接口返回三者一致，且重复收获已被处理的地块会被拒绝。

---

## 第七阶段：行囊基础系统 (Phase 7: Inventory - Basic System)

本阶段目标：实现一个最简版行囊（Inventory），支持存放和展示灵草等基础物品，打通与洞府收获接口的联动。复杂物品类型与排序、筛选等以后扩展。

### 步骤 7.1: 设计物品与行囊数据模型
*   **指令**: 在 `prisma/schema.prisma` 中为行囊新增模型，用于表示玩家拥有的物品条目。模型至少应包含所属玩家 ID、物品标识（与灵草等配置表对应）、物品类型、物品数量，以及创建与更新时间。
*   *   为 `(playerId, itemId)` 建立唯一索引，从数据库层面保证“同一玩家 + 同一物品标识只准一条记录”，避免重复条目。
*   *   物品类型字段（如 `type: "herb" | "pill" | "equipment"`）使用枚举或受限字符串，为后续扩展提供基础。
*   **验证**: 保存 Schema 后运行 `npx prisma validate`，确保物品与行囊模型定义合法，没有语法错误，并通过字段命名与类型检查；在 Prisma Studio 中验证唯一索引生效。

### 步骤 7.2: 同步行囊模型到数据库
*   **指令**: 运行 `npx prisma db push` 将行囊相关模型同步到 SQLite 数据库。
*   **验证**: 打开 Prisma Studio，确认新表存在并包含预期字段，手动插入一条物品记录，确认保存和展示均正常。

### 步骤 7.3: 行囊与配置表的映射约定
*   **指令**: 确定行囊中物品标识与配置中的物品（例如灵草配置）之间的映射规则，约定统一使用的物品 ID 命名方式，并在 `utils/gameConstants.ts` 或类似配置文件中为已有灵草配置增加可选的“物品 ID”字段与“物品类型”字段。
*   **验证**: 通过简单脚本或日志输出，验证从某个物品 ID 能够找到对应的配置项，并确保不会出现重复或无法识别的 ID；确认物品类型字段与数据库中记录一致。

### 步骤 7.4: 后端工具逻辑 - 向行囊增加物品
*   **指令**: 在后端创建一个专门用于更新行囊的工具函数或服务层逻辑，负责根据玩家 ID 和物品 ID 进行查询与增量更新：若该玩家已有相同物品条目则累加数量，否则新建一条记录。此逻辑将被洞府收获等接口复用。
*   *   利用 `(playerId, itemId)` 的唯一索引，在并发场景下通过事务或 `upsert` 操作保证最终只存在一条记录且数量正确累加。
*   **验证**: 在后端通过临时脚本或调试接口调用该工具逻辑，多次为同一玩家、同一物品 ID 增加物品，确认最终数据库中只存在一条记录且数量正确累加；并在并发调用下无重复记录。

### 步骤 7.5: 洞府收获与行囊联动
*   **指令**: 回到洞府收获接口，将原本仅返回收获结果的逻辑扩展为：在成功收获灵草后，调用行囊更新工具逻辑，将对应灵草物品 ID、物品类型和数量加入当前玩家行囊。保持接口返回中包含收获详情，方便前端提示。
*   **验证**: 通过完整“种植 → 成熟 → 收获”流程，检查收获完成后玩家行囊表中自动增加相应物品记录；多次重复该流程时，数量按预期累加，物品类型字段与配置一致。

### 步骤 7.6: 后端 API - 查询行囊内容
*   **指令**: 创建用于获取当前玩家行囊内容的接口，例如 `server/api/inventory/list.get.ts`。接口通过签名 token 获取玩家身份，从数据库读取该玩家所有物品条目，并将物品 ID 映射为可读名称和类别信息后返回。
*   **验证**: 使用 HTTP 客户端在登录状态下调用行囊查询接口，确认返回结果中包含玩家所有物品、数量正确且名称显示与配置表一致；在未登录或 token 无效时调用应被拒绝。

### 步骤 7.7: 前端页面 - 行囊基础布局
*   **指令**: 在 `pages/inventory.vue` 中实现基础行囊展示界面，使用 Vant 的列表或单元格组件显示物品名称、数量以及可选的简单描述。页面加载时调用行囊查询接口，将返回的数据映射到界面。
*   **验证**: 登录游戏后通过底部导航进入行囊页面，确认可以看到从数据库读取到的物品列表，并且与实际行囊表中的记录数量一致。

### 步骤 7.8: 前端交互 - 来自洞府的收获反馈
*   **指令**: 在洞府收获成功后，除了当前的提示信息外，增加一处引导操作，例如在提示中提供“查看行囊”按钮或文案，点击后跳转到行囊页面，使玩家能立即看到新获得的物品。
*   **验证**: 完成一轮收获操作后，通过提示跳转到行囊页面，确认新获得的物品已经正确显示，且页面跳转与状态更新均无异常。

### 步骤 7.9: 前端刷新策略与错误处理
*   **指令**: 为行囊页面和洞府页面补充基础的刷新和错误处理逻辑，例如在接口调用失败时显示错误提示，在玩家返回页面时重新拉取最新数据，并避免使用已经过期的本地缓存。
*   *   洞府与行囊页面的自动刷新间隔推荐统一为每 5 秒一次，配合显式的手动刷新按钮，避免过于频繁请求。
*   *   前端在处理错误时统一读取后端返回的 `code` 与 `message`，根据 `message` 直接展示给玩家，根据 `code` 决定是否需要额外逻辑（如跳转登录页或刷新数据）。
*   **验证**: 模拟后端接口暂时不可用的情况（例如临时更改接口返回状态码），确认前端能够向玩家准确提示错误，并在恢复正常后重新加载数据显示正确；在 token 失效时，根据 `code` 自动跳转到登录页。
